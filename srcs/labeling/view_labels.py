'''
Usage: view_labels.py {3D, 2D}

Visualize the labels that have been created with respect to the point clouds,
in either 2D or 3D
'''

from math import radians
import os
from random import shuffle
import sys

import numpy as np

sys.path.append(os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from transformations import euler_matrix
from bev import BEV
from config import exp_name
from keyboard_labeler import Labeler
from utils import load_config

if len(sys.argv) != 2 or sys.argv[1] not in ('3D', '2D'):
    print('Usage: view_labels.py {3D, 2D}')
    quit()

config, _, _, _ = load_config(exp_name)
geom = config['geometry']
bev = BEV(geom)

# Directory containing the labels generated from run_labeler.py
label_dir = os.path.join(config['data_dir'], 'labels')

# Directory containing the the .npz files generated by bag_extractor.py
raw_dir = os.path.join(config['data_dir'], 'raw')

labeler = Labeler(view_only=True)

dirs = [x for x in next(os.walk(label_dir))[1]]

for d in dirs:
    files = os.listdir(os.path.join(label_dir, d))
    files = sorted(list(files), key=lambda x: int(x[:-4]))

    shuffle(files)

    for f in files:
        if not f.endswith('.npz'):
            continue

        label_path = os.path.join(label_dir, d, f)

        if os.path.exists(label_path):
            # Load the labels for this point cloud
            label_data = np.load(label_path)

            # Ensure the labels are in bounds
            labels = bev.crop_labels(label_data['labels'])

            # Load the point cloud into an array
            raw_path = os.path.join(raw_dir, d, f)
            raw_data = np.load(raw_path)
            pts = np.copy(raw_data['pointcloud'][:, 0:3])

            # Make a rotation matrix to rotate points
            roll = 0
            pitch = radians(-3.)
            R = euler_matrix(-roll, -pitch, 0)[0:3, 0:3]

            # Apply the rotation matrix to the points
            pts = np.matmul(R, pts.T).T

            # Show only points that are in bounds in X and Y directions
            idx = ((pts[:, 0] > geom['W1']) &
                   (pts[:, 0] < geom['W2']) &
                   (pts[:, 1] < geom['L2']) &
                   (pts[:, 1] > geom['L1']))
            pts = pts[idx]

            print('\nLabels:')
            for label in labels:
                print('X: {:.2f}, Y: {:.2f}     X: {:.2f}, Y: {:.2f}'.format(
                    label[0], label[2], label[1], label[3]))

            # Get an image of the point cloud and labels in 2D
            bev_img = bev.pointcloud_to_bev(
                np.copy(raw_data['pointcloud'][:, 0:3])
            )

            data_2D = np.load(os.path.join(raw_dir, d, f))
            pts_2D = data_2D['pointcloud']

            if sys.argv[1] == '2D':
                formatted_labels = []
                for label in labels:
                    formatted_labels.append([label[0:2], label[2:]])
                labeler.plot_points_and_labels(pts_2D, formatted_labels)

            else:
                # Plot the point cloud and labels in 3D
                bev.visualize_lines_3d(labels, pts, order='xxyy')
