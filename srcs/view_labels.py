from sys import argv
import os
import errno
from glob import glob
from scipy.spatial.transform import Rotation
from random import shuffle

import matplotlib
from matplotlib import pyplot as plt

from transformations import euler_matrix

import numpy as np
import open3d as o3d

from config import exp_name

from plane_fitter import fit_plane
from math import radians

from bev import  BEV
from utils import load_config

config, _, _, _ = load_config(exp_name)
geom = config["geometry"]
bev = BEV(geom)

# Directory containing the labels generated from run_labeler.py
label_dir = os.path.join(config['data_dir'], 'labels')

# Directory containing the the .npz files generated by bag_extractor.py
raw_dir = os.path.join(config['data_dir'], 'raw')

dirs = [x for x in next(os.walk(label_dir))[1]]

for d in dirs:
    files = os.listdir(os.path.join(label_dir, d))
    files = sorted(list(files), key=lambda x: int(x[:-4]) )

    shuffle(files)

    for f in files:
        if not f.endswith(".npz"):
            continue

        label_path = os.path.join(label_dir, d, f)

        if os.path.exists(label_path):
            # Load the labels for this point cloud
            label_data = np.load(label_path)

            # Ensure the labels are in bounds
            labels = bev.crop_labels(label_data['labels'])

            # Load the point cloud into an array
            raw_path = os.path.join(raw_dir, d, f)
            raw_data = np.load(raw_path)
            pts = np.copy(raw_data['pointcloud'][:,0:3])

            # Make a rotation matrix to rotate points
            roll = 0
            pitch = radians(-3.)
            R = euler_matrix(-roll, -pitch, 0)[0:3,0:3]

            # Apply the rotation matrix to the points
            pts = np.matmul(R, pts.T).T

            # Show only points that are in bounds in X and Y directions
            idx =  ((pts[:,0] > geom["W1"]) & 
                    (pts[:,0] < geom["W2"]) & 
                    (pts[:,1] < geom["L2"]) & 
                    (pts[:,1] > geom["L1"]))
            pts = pts[idx]

            print("Labels:")
            print(labels)

            label_map, class_map, instance_map, num_instances = \
                    bev.make_targets(labels)

            fraction = float(np.count_nonzero(class_map)) / (class_map.shape[0] * class_map.shape[1])
            print("foreground fraction: %.6f" % fraction)

            bev_img = bev.pointcloud_to_bev(
                np.copy(raw_data['pointcloud'][:,0:3])
            )

            labels_bev = bev.labels_to_bev(labels)
            
            bev.visualize_lines_3d(labels, pts, order='xxyy')


